{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation site of SimuQ","text":"<p>This is the documentation site of SimuQ. For tutorials and examples please check the main website of SimuQ</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li><code>Expressions</code> - The variable and expression classes of SimuQ.</li> <li><code>Hamiltonian</code> - The time-independent Hamiltonian class, constant or parameterized.</li> <li><code>Environments</code> - The basic quantum environment class and site classes, including qubit, boson, and fermion.</li> <li><code>Quantum Systems</code> - The target quantum system class.</li> <li><code>Quantum Devices</code> - The classes for AAIS of quantum devices.</li> <li><code>SimuQ Solver</code> - The solver-based compiler of SimuQ.</li> </ul>"},{"location":"environment/","title":"Quantum Environments","text":"<p>The classes describing quantum environments.</p> <p>A quantum environment is a container of sites. Either target quantum systems or quantum machines are described by its children classes.</p> <p>A site is the basic unit describing a quantized physics entity. It includes qubit / bosonic / fermionic states, or other customized  types of sites. Each site contains a set of site operators. These  operators will be used in the construction of Hamiltonians.</p> <p>Currently operators are stored as strings. In future these may be substituted by operator classes.</p>"},{"location":"environment/#SimuQ.simuq.environment.BaseParticle","title":"<code>BaseParticle</code>","text":"<p>         Bases: <code>BaseSite</code></p> <p>The basic particle site.</p> <p>By default, there are annihilation and creation operators. Additionally, to be consistent with qubit, I represents the identity.</p> Source code in <code>SimuQ/simuq/environment.py</code> <pre><code>class BaseParticle(BaseSite) :\n\"\"\" The basic particle site.\n\n    By default, there are annihilation and creation operators.\n    Additionally, to be consistent with qubit, I represents the identity.\n    \"\"\"\n    def __init__(self, qs) :\n        super().__init__(qs)\n        qs.sites_type.append('particle')\n        self.a = self.gen_a()\n        self.c = self.gen_c()\n        self.I = self.gen_I()\n\n    def gen_a(self) :\n        return self.createOp(\"a\")\n\n    def gen_c(self) :\n        return self.createOp(\"c\")\n\n    def gen_I(self) :\n        return self.createOp(\"\")\n</code></pre>"},{"location":"environment/#SimuQ.simuq.environment.BaseQuantumEnvironment","title":"<code>BaseQuantumEnvironment</code>","text":"<p>The basic quantum environment.</p> <p>It models a system to which quantum sites belong to.</p> <p>The sites are stored in a sequence, where their types are stored in list sites_type.</p> Source code in <code>SimuQ/simuq/environment.py</code> <pre><code>class BaseQuantumEnvironment :\n\"\"\" The basic quantum environment.\n\n    It models a system to which quantum sites belong to.\n\n    The sites are stored in a sequence, where their types are stored in\n    list sites_type.\n    \"\"\"\n    def __init__(self) :\n        self.sites = []\n        self.sites_type = []\n        self.num_sites = 0\n\n    def identity(self) :\n        return TIHamiltonian.identity(self.sites_type)\n\n    def singletonOp(self, index, op) :\n        return TIHamiltonian.op(self.sites_type, index, op)\n</code></pre>"},{"location":"environment/#SimuQ.simuq.environment.BaseSite","title":"<code>BaseSite</code>","text":"<p>The basic quantum site.</p> Source code in <code>SimuQ/simuq/environment.py</code> <pre><code>class BaseSite :\n\"\"\" The basic quantum site.\n    \"\"\"\n    def __init__(self, qs) :\n        self.index = qs.num_sites\n        self.qs = qs\n        qs.num_sites += 1\n        qs.sites.append(self)\n\n    def createOp(self, op) :\n        h = self.qs.singletonOp(self.index, op)\n        return h\n</code></pre>"},{"location":"environment/#SimuQ.simuq.environment.boson","title":"<code>boson</code>","text":"<p>         Bases: <code>BaseParticle</code></p> <p>The bosonic site</p> Source code in <code>SimuQ/simuq/environment.py</code> <pre><code>class boson(BaseParticle) :\n\"\"\" The bosonic site\n    \"\"\"\n    def __init__(self, qs) :\n        super().__init__(qs)\n        qs.sites_type[-1] = 'boson'\n</code></pre>"},{"location":"environment/#SimuQ.simuq.environment.fermion","title":"<code>fermion</code>","text":"<p>         Bases: <code>BaseParticle</code></p> <p>The fermionic site</p> Source code in <code>SimuQ/simuq/environment.py</code> <pre><code>class fermion(BaseParticle) :\n\"\"\" The fermionic site\n    \"\"\"\n    def __init__(self, qs) :\n        super().__init__(qs)\n        qs.sites_type[-1] = 'fermion'\n</code></pre>"},{"location":"environment/#SimuQ.simuq.environment.qubit","title":"<code>qubit</code>","text":"<p>         Bases: <code>BaseSite</code></p> <p>The qubit site.</p> <p>By default, there are X, Y, Z, I defined as site operators of a qubit site.</p> Source code in <code>SimuQ/simuq/environment.py</code> <pre><code>class qubit(BaseSite) :\n\"\"\" The qubit site.\n\n    By default, there are X, Y, Z, I defined as site operators\n    of a qubit site.\n    \"\"\"\n    def __init__(self, qs) :\n        super().__init__(qs)\n        qs.sites_type.append('qubit')\n        self.X = self.gen_X()\n        self.Y = self.gen_Y()\n        self.Z = self.gen_Z()\n        self.I = self.gen_I()\n\n    def gen_X(self) :\n        return self.createOp(\"X\")\n\n    def gen_Y(self) :\n        return self.createOp(\"Y\")\n\n    def gen_Z(self) :\n        return self.createOp(\"Z\")\n\n    def gen_I(self) :\n        return self.createOp(\"\")\n</code></pre>"},{"location":"expression/","title":"SimuQ Expressions","text":"<p>The class file describing expressions with variables.</p> <p>Expressions are effectively functions taking a valuation of variables and generating (real) results. We support the natural construction of expressions, where users write  +, -, *, / naturally on expressions.</p> <p>These expressions will be used in representing the  coefficients in machine's instruction Hamiltonians, where  variables belonging to the instruction have effects on the Hamiltonian.</p> <p>The basic operations are overloaded.</p>"},{"location":"expression/#SimuQ.simuq.expression.BaseVar","title":"<code>BaseVar</code>","text":"<p>The basic variables.</p> <p>The constrainsts specific to the variables are stored here, like the initial value, lower and upper bounds of them.</p> Source code in <code>SimuQ/simuq/expression.py</code> <pre><code>class BaseVar :\n\"\"\" The basic variables.\n\n    The constrainsts specific to the variables are stored here,\n    like the initial value, lower and upper bounds of them.\n    \"\"\"\n    def __init__(self, mach) :\n        self.mach = mach\n        self.init_value = 0\n        self.lower_bound = -np.inf\n        self.upper_bound = np.inf\n\n    def to_exp(self) :\n        pass\n\n    def __neg__(self) :\n        return -self.to_exp()\n\n    def __add__(self, other) :\n        return self.to_exp() + other\n\n    def __mul__(self, other) :\n        return self.to_exp() * other\n\n    def __sub__(self, other) :\n        return self.to_exp() - other\n\n    def __truediv__(self, other) :\n        return self.to_exp() / other\n</code></pre>"},{"location":"expression/#SimuQ.simuq.expression.Expression","title":"<code>Expression</code>","text":"<p>The expressions.</p> <p>It is effectively a function taking a valuation of global variables and local variables and generating a number.</p> Source code in <code>SimuQ/simuq/expression.py</code> <pre><code>class Expression :\n\"\"\" The expressions.\n\n    It is effectively a function taking a valuation of global variables\n    and local variables and generating a number.\n    \"\"\"\n    def __init__(self, mach, exp) :\n        self.mach = mach\n        self.exp = exp\n\n    @classmethod\n    def unit(cls, mach) :\n        exp = lambda gvars, lvars : 1\n        return cls(mach, exp)\n\n    @classmethod\n    def id_gvar(cls, mach, index) :\n        exp = lambda gvars, lvars : gvars[index]\n        return cls(mach, exp)\n\n    @classmethod\n    def id_lvar(cls, mach, index) :\n        exp = lambda gvars, lvars : lvars[index]\n        return cls(mach, exp)\n\n    @classmethod\n    def cos(cls, e) :\n        if type(e) == int  or  type(e) == float  or  type(e) == complex :\n            return math.cos(e)\n        if isinstance(e, BaseVar) :\n            e = e.to_exp()\n        exp = lambda gvars, lvars : math.cos(e.exp(gvars, lvars))\n        return cls(e.mach, exp)\n\n    @classmethod\n    def sin(cls, e) :\n        if type(e) == int  or  type(e) == float  or  type(e) == complex :\n            return math.sin(e)\n        if isinstance(e, BaseVar) :\n            e = e.to_exp()\n        exp = lambda gvars, lvars : math.sin(e.exp(gvars, lvars))\n        return cls(e.mach, exp)\n\n    def __neg__(self) :\n        exp = lambda gvars, lvars : -self.exp(gvars, lvars)\n        e = Expression(self.mach, exp)\n        return e\n\n    def __add__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex :\n            exp = lambda gvars, lvars : self.exp(gvars, lvars) + other\n            e = Expression(self.mach, exp)\n            return e\n        if isinstance(other, BaseVar) :\n            other = other.to_exp()\n        if not hasattr(other, \"exp\") :\n            return NotImplemented\n        exp = lambda gvars, lvars : self.exp(gvars, lvars) + other.exp(gvars, lvars)\n        e = Expression(self.mach, exp)\n        return e\n\n    def __sub__(self, other) :\n        return self.__add__(other.__neg__())\n\n    def __radd__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex :\n            return self.__add__(other)\n        elif isinstance(other, BaseVar) :\n            other = other.to_exp()\n            return self.__add__(other)\n        else :\n            return NotImplemented\n\n    def __mul__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex :\n            exp = lambda gvars, lvars : self.exp(gvars, lvars) * other\n            e = Expression(self.mach, exp)\n            return e\n        if isinstance(other, BaseVar) :\n            other = other.to_exp()\n        if not hasattr(other, \"exp\") :\n            return NotImplemented\n        exp = lambda gvars, lvars : self.exp(gvars, lvars) * other.exp(gvars, lvars)\n        e = Expression(self.mach, exp)\n        return e\n\n    def __rmul__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex :\n            return self.__mul__(other)\n        elif isinstance(other, BaseVar) :\n            other = other.to_exp()\n            return self.__mul__(other)\n        else :\n            return NotImplemented\n\n    def __pow__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex :\n            exp = lambda gvars, lvars : self.exp(gvars, lvars) ** other\n            e = Expression(self.mach, exp)\n            return e\n        if isinstance(other, BaseVar) :\n            other = other.to_exp()\n        if not hasattr(other, \"exp\") :\n            return NotImplemented\n        exp = lambda gvars, lvars : self.exp(gvars, lvars) ** other.exp(gvars, lvars)\n        e = Expression(self.mach, exp)\n        return e\n\n    def __truediv__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex :\n            exp = lambda gvars, lvars : self.exp(gvars, lvars) / other\n            e = Expression(self.mach, exp)\n            return e\n        if isinstance(other, BaseVar) :\n            other = other.to_exp()\n        if not hasattr(other, \"exp\") :\n            return NotImplemented\n        exp = lambda gvars, lvars : self.exp(gvars, lvars) / other.exp(gvars, lvars)\n        e = Expression(self.mach, exp)\n        return e\n\n    def __rtruediv__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex :\n            exp = lambda gvars, lvars : other / self.exp(gvars, lvars)\n            e = Expression(self.mach, exp)\n            return e\n        if isinstance(other, BaseVar) :\n            other = other.to_exp()\n        if not hasattr(other, \"exp\") :\n            return NotImplemented\n        exp = lambda gvars, lvars : other.exp(gvars, lvars) / self.exp(gvars, lvars)\n        e = Expression(self.mach, exp)\n        return e\n\n    def exp_eval(self, gvars, lvars) :\n        return self.exp(gvars, lvars)\n</code></pre>"},{"location":"hamiltonian/","title":"Time-independent Hamiltonian","text":"<p>The class file for time independent Hamiltonian.</p> <p>A TIHamiltonian is stored as a sum of product terms: a coefficient times a product of basic operators. The products of basic operators are stored as a list of operators (currently strings).</p> <p>In the worst case, this representation may take exponential resources. In practice, it is enough for nowadays machines.</p> <p>Natural computation operations are overloaded.  Pauli basis products are symbolically calculated, so that commutativity test is possible.</p>"},{"location":"hamiltonian/#SimuQ.simuq.hamiltonian.TIHamiltonian","title":"<code>TIHamiltonian</code>","text":"<p>The time-independent Hamiltonian</p> <p>The underlying data-structure to store it is a list of tuples (h, c). Here h is a product Hamiltonian,  represented by a list of site operators on the sites.  c is the coefficient corresponding to h, and can either be a real number or an Expression. </p> <p>The site operator algebras are symbolically dealt with  here, since fermionic operators' algebra is position-related.</p> <p>We can also test commutativity of Hamiltonians, and  calculate the sites the Hamiltonian is acting non- trivially on.</p> Source code in <code>SimuQ/simuq/hamiltonian.py</code> <pre><code>class TIHamiltonian :\n\"\"\" The time-independent Hamiltonian\n\n    The underlying data-structure to store it is a list of\n    tuples (h, c). Here h is a product Hamiltonian, \n    represented by a list of site operators on the sites. \n    c is the coefficient corresponding to h, and can either\n    be a real number or an Expression. \n\n    The site operator algebras are symbolically dealt with \n    here, since fermionic operators' algebra is position-related.\n\n    We can also test commutativity of Hamiltonians, and \n    calculate the sites the Hamiltonian is acting non-\n    trivially on.\n    \"\"\"\n\n    def __init__(self, sites_type, ham) :\n        self.sites_type = sites_type\n        self.ham = ham\n        self.saved_t_sites = None\n        self.cleanHam()\n\n    @classmethod\n    def empty(cls, sites_type) :\n        ham = []\n        return cls(sites_type, ham)\n\n    @classmethod\n    def identity(cls, sites_type) :\n        num_sites = len(sites_type)\n        prod = ['' for i in range(num_sites)]\n        ham = [(prod, 1)]\n        return cls(sites_type, ham)\n\n    @classmethod\n    def op(cls, sites_type, index, op) :\n        num_sites = len(sites_type)\n        prod = ['' for i in range(num_sites)]\n        prod[index] = op\n        ham = [(prod, 1)]\n        return cls(sites_type, ham)\n\n    def operAlgebra(self) :\n        self.extend_ham_by_sites()\n\n        i = 0\n        while i &lt; len(self.ham) :\n            (h, coef) = self.ham[i]\n            for j in range(len(h)) :\n                if self.sites_type[j] == 'qubit' :\n                    if h[j] == 'XX'  or  h[j] == 'YY'  or  h[j] == 'ZZ' :\n                        h[j] = ''\n                    elif h[j] == 'XY' :\n                        h[j] = 'Z'\n                        coef *= 1j\n                    elif h[j] == 'YX' :\n                        h[j] = 'Z'\n                        coef *= -1j\n                    elif h[j] == 'YZ' :\n                        h[j] = 'X'\n                        coef *= 1j\n                    elif h[j] == 'ZY' :\n                        h[j] = 'X'\n                        coef *= -1j\n                    elif h[j] == 'ZX' :\n                        h[j] = 'Y'\n                        coef *= 1j\n                    elif h[j] == 'XZ' :\n                        h[j] = 'Y'\n                        coef *= -1j\n                    self.ham[i]\n            for j in range(len(h)) :\n                if self.sites_type[j] == 'boson' :\n                    s = h[j].find('ac')\n                    while s != -1 :\n                        h_copy = h.copy()\n                        h_copy[j] = h_copy[j].replace('ac', 'ca', 1)\n                        h[j] = h[j].replace('ac', '', 1)\n                        self.ham.append((h_copy, coef))\n                        s = h[j].find('ac')\n                elif self.sites_type[j] == 'fermion' :\n                    s = h[j].find('ac')\n                    while s != -1 :\n                        h_copy = h.copy()\n                        h_copy[j] = h_copy[j].replace('ac', 'ca', 1)\n                        h[j] = h[j].replace('ac', '', 1)\n                        self.ham.append((h_copy, -coef))\n                        s = h[j].find('ac')\n            self.ham[i] = (h, coef)\n            i += 1\n\n\n    def cleanHam(self, tol = 1e-10) :\n        self.operAlgebra()\n\n        i = 0\n        while i &lt; len(self.ham) :\n            for j in range(i) :\n                if self.ham[j][0] == self.ham[i][0] :\n                    self.ham[j] = (self.ham[j][0], self.ham[j][1] + self.ham[i][1])\n                    del self.ham[i]\n                    i -= 1\n                    break\n            i += 1\n        i = 0\n\n        while i &lt; len(self.ham) :\n            if isinstance(self.ham[i][1], Expression) :\n                break\n            if abs(self.ham[i][1]) &lt; tol :\n                del self.ham[i]\n                continue\n            i += 1\n\n    def extend_ham_by_sites(self) :\n        for i in range(len(self.ham)) :\n            (h, coef) = self.ham[i]\n            if len(h) &lt; len(self.sites_type) :\n                h += [''] * (len(self.sites_type) - len(h))\n                self.ham[i] = (h, coef)\n\n    def extend_sites(self, new_sites_type) :\n        if len(new_sites_type) &lt;= len(self.sites_type) :\n            return\n        for i in range(len(self.sites_type)) :\n            if self.sites_type[i] != new_sites_type[i] :\n                raise Exception(\"Sites type inconsistent!\")\n        add_num = len(new_sites_type) - len(self.sites_type)\n        new_ham = [(self.ham[i][0] + [''] * add_num, self.ham[i][1]) for i in range(len(self.ham))]\n        self.sites_type = new_sites_type\n        self.ham = new_ham\n        if self.saved_t_sites is not None :\n            self.saved_t_sites += [0 for j in range(add_num)]\n\n    def __neg__(self) :\n        ham = copy(self.ham)\n        for i in range(len(ham)) :\n            ham[i] = (ham[i][0], -ham[i][1])\n        h = TIHamiltonian(self.sites_type, ham)\n        return h\n\n    def __add__(self, other) :\n        # need more typing restrictions\n        if type(other) == int  or  type(other) == float  or  type(other) == complex  or  isinstance(other, Expression) :\n            other = other * TIHamiltonian.empty()\n        if self.sites_type != other.sites_type :\n            self.extend_sites(other.sites_type)\n            other.extend_sites(self.sites_type)\n        ham = copy(self.ham)\n        ham += other.ham\n        h = TIHamiltonian(self.sites_type, ham)\n        h.cleanHam()\n        return h\n\n    def __radd__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex  or  isinstance(other, Expression) :\n            return self.__add__(other * TIHamiltonian.empty(self.sites_type))\n        else :\n            return NotImplemented\n\n    def __sub__(self, other) :\n        # need more typing restrictions\n        if type(other) == int  or  type(other) == float  or  type(other) == complex  or  isinstance(other, Expression) :\n            other = other * TIHamiltonian.empty(self.sites_type)\n        if self.sites_type != other.sites_type :\n            self.extend_sites(other.sites_type)\n            other.extend_sites(self.sites_type)\n        ham = copy(self.ham)\n        ham += other.__neg__().ham\n        h = TIHamiltonian(self.sites_type, ham)\n        h.cleanHam()\n        return h\n\n    def __rsub__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex  or  isinstance(other, Expression) :\n            return (other * TIHamiltonian.empty(self.sites_type)) - self\n        else :\n            return NotImplemented\n\n    @staticmethod\n    def strlist_mul(sites_type, a, b) :\n        c = []\n        coef = 1\n\n        # Use a suffix sum to calculate the number of fermionic operators after site i.\n        num_ferm_ope_backward = [0 for i in range(len(sites_type))]\n        for i in range(len(sites_type) - 1, 1, -1) :\n            num_ferm_ope_backward[i - 1] = num_ferm_ope_backward[i]\n            if sites_type[i] == 'fermion' :\n                num_ferm_ope_backward[i - 1] += len(a[i])\n\n        for i in range(len(sites_type)) :\n            if sites_type[i] == 'qubit' :\n                c.append(a[i] + b[i])\n            elif sites_type[i] == 'boson' :\n                c.append(a[i] + b[i])\n            elif sites_type[i] == 'fermion' :\n                c.append(a[i] + b[i])\n                if num_ferm_ope_backward[i] % 2 == 1  and  len(b[i]) % 2 == 1 :\n                    coef *= -1\n\n        return (c, coef)\n\n    def scalar_mul(self, other) :\n        ham = copy(self.ham)\n        for i in range(len(ham)) :\n            ham[i] = (ham[i][0], ham[i][1] * other)\n        h = TIHamiltonian(self.sites_type, ham)\n        return h\n\n    def __mul__(self, other) :\n        # need more typing restrictions\n        if type(other) == int  or  type(other) == float  or  type(other) == complex  or  isinstance(other, Expression) :\n            return self.scalar_mul(other)\n        self.extend_ham_by_sites()\n        other.extend_ham_by_sites()\n        if self.sites_type != other.sites_type :\n            self.extend_sites(other.sites_type)\n            other.extend_sites(self.sites_type)\n        ham = []\n        for (prod1, coef1) in self.ham :\n            for (prod2, coef2) in other.ham :\n                (prod, coef3) = self.strlist_mul(self.sites_type, prod1, prod2)\n                ham.append((prod, coef1 * coef2 * coef3))\n        h = TIHamiltonian(self.sites_type, ham)\n        h.cleanHam()\n        return h\n\n    def __truediv__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex  or  isinstance(other, Expression) :\n            return self.scalar_mul(1/other)\n        else :\n            return NotImplemented\n\n    def __rmul__(self, other) :\n        if type(other) == int  or  type(other) == float  or  type(other) == complex  or  isinstance(other, Expression) :\n            return self.scalar_mul(other)\n        else :\n            return NotImplemented\n\n    def exp_eval(self, gvars, lvars) :\n        ham = copy(self.ham)\n        for i in range(len(ham)) :\n            ham[i] = (ham[i][0], ham[i][1].exp_eval(gvars, lvars))\n        h = TIHamiltonian(self.sites_type, ham)\n        return h\n\n    def is_empty(self) :\n        abs_sum = 0\n        for (prod, c) in self.ham :\n            abs_sum += abs(c)\n        if abs_sum &lt; 1e-8 :\n            return True\n        else :\n            return False\n\n    @staticmethod\n    def commutativity_test(h1, h2, derived = False) :\n        if derived :\n            t_sites1 = h1.touched_sites()\n            t_sites2 = h2.touched_sites()\n            for i in range(len(h1.sites_type)) :\n                if t_sites1[i] == 1  and  t_sites2[i] == 1 :\n                    return False\n            return True\n        return (h1 * h2 - h2 * h1).is_empty()\n\n    def touched_sites(self) :\n        if self.saved_t_sites != None :\n            return self.saved_t_sites\n        ret = [0 for i in range(len(self.sites_type))]\n        for (prod, t) in self.ham :\n            for i in range(len(self.sites_type)) :\n                if prod[i] != '' :\n                    ret[i] = 1\n        self.saved_t_sites = ret\n        return ret\n</code></pre>"},{"location":"qmachine/","title":"Quantum Devices","text":"<p>The class file for quantum machines.</p> <p>One can implement an AAIS in a QMachine. Signal lines and instructions are supported inside it.</p> <p>A quantum machine is essentially a container of signal lines, instructions and (local or global) variables.</p> <p>A signal line contains multiple instructions. Instructions sharing a signal line cannot be called simultaneously.</p> <p>Global variables are defined for the QMachine as a globally tunable parameter. They will be fixed for the whole experiment.</p> <p>An instruction may contain several local variables. Local variables can be tuned for each call of the instruction. Both variables can be used in the description of its Hamiltonian. TODO: Add API for variables' bounds.</p>"},{"location":"qmachine/#SimuQ.simuq.qmachine.GlobalVar","title":"<code>GlobalVar</code>","text":"<p>         Bases: <code>BaseVar</code></p> <p>A global variable, belonging to a QMachine.</p> <p>One can set its initial value, lower and upper bounds when declaring it.</p> Source code in <code>SimuQ/simuq/qmachine.py</code> <pre><code>class GlobalVar(BaseVar) :\n\"\"\" A global variable, belonging to a QMachine.\n\n    One can set its initial value, lower and upper bounds\n    when declaring it.\n    \"\"\"\n    def __init__(self, mach, init_value = 0, lower_bound = -np.inf, upper_bound = np.inf) :\n        super().__init__(mach)\n        self.index = mach.num_gvars\n        mach.num_gvars += 1\n        mach.gvars.append(self)\n        self.init_value = init_value\n        self.lower_bound = lower_bound\n        self.upper_bound = upper_bound\n\n    def to_exp(self) :\n        e = Expression.id_gvar(self.mach, self.index)\n        return e\n</code></pre>"},{"location":"qmachine/#SimuQ.simuq.qmachine.Instruction","title":"<code>Instruction</code>","text":"<p>An instruction.</p> <p>It contains the local variables belonging to it, its property, and its instruction Hamiltonian.</p> Source code in <code>SimuQ/simuq/qmachine.py</code> <pre><code>class Instruction :\n\"\"\" An instruction.\n\n    It contains the local variables belonging to it, its\n    property, and its instruction Hamiltonian.\n    \"\"\"\n    def __init__(self, line, prop, name = 'ins') :\n        self.mach = line.mach\n        self.line = line\n        line.inss.append(self)\n        self.index = self.mach.num_inss\n        self.mach.num_inss += 1\n        self.vars_index = []\n        self.prop = prop\n        self.name = name\n        self.is_sys_ham = False\n\n    def set_ham(self, h) :\n        newh = copy(h)\n        for i in range(len(h.ham)) :\n            if not isinstance(h.ham[i][1], Expression) :\n                newh.ham[i] = (h.ham[i][0], h.ham[i][1] * Expression.unit(self.mach))\n        self.h = newh\n\n    def exp_eval(self, gvars, lvars) :\n        return self.h.exp_eval(gvars, lvars)\n</code></pre>"},{"location":"qmachine/#SimuQ.simuq.qmachine.LocalVar","title":"<code>LocalVar</code>","text":"<p>         Bases: <code>BaseVar</code></p> <p>A local vabiable, belonging to an instruction.</p> <p>One can set its initial value, lower and upper bounds when declaring it.</p> Source code in <code>SimuQ/simuq/qmachine.py</code> <pre><code>class LocalVar(BaseVar) :\n\"\"\" A local vabiable, belonging to an instruction.\n\n    One can set its initial value, lower and upper bounds\n    when declaring it.\n    \"\"\"\n    def __init__(self, ins, init_value = 0, lower_bound = -np.inf, upper_bound = np.inf) :\n        mach = ins.mach\n        super().__init__(mach)\n        self.index = mach.num_lvars\n        ins.vars_index.append(self.index)\n        mach.num_lvars += 1\n        mach.lvars.append(self)\n        self.init_value = init_value\n        self.lower_bound = lower_bound\n        self.upper_bound = upper_bound\n\n    def to_exp(self) :\n        e = Expression.id_lvar(self.mach, self.index)\n        return e\n</code></pre>"},{"location":"qmachine/#SimuQ.simuq.qmachine.QMachine","title":"<code>QMachine</code>","text":"<p>         Bases: <code>BaseQuantumEnvironment</code></p> <p>A quantum device described by its AAIS.</p> <p>It stores the signal lines, instructions, local  variables and global variables.</p> Source code in <code>SimuQ/simuq/qmachine.py</code> <pre><code>class QMachine(BaseQuantumEnvironment) :\n\"\"\" A quantum device described by its AAIS.\n\n    It stores the signal lines, instructions, local \n    variables and global variables.\n    \"\"\"\n    def __init__(self) :\n        super().__init__()\n        self.num_gvars = 0\n        self.gvars = []\n        self.num_lvars = 0\n        self.lvars = []\n        self.num_lines = 0\n        self.lines = []\n        self.num_inss = 0\n        self.sys_ham = 0\n        self.with_sys_ham = False\n        self.instantiated = False\n\n    def set_sys_ham(self, h) :\n        self.sys_ham = h\n        self.with_sys_ham = True\n\n    def instantiate_sys_ham(self) :\n        if self.with_sys_ham  and  not self.instantiated :\n            SysLine = SignalLine(self)\n            SysIns = Instruction(SysLine, 'native', 'System Hamiltonian')\n            SysIns.set_ham(self.sys_ham)\n            SysIns.is_sys_ham = True\n            self.instantiated = True\n\n    def extend_instruction_sites(self) :\n        for line in self.lines :\n            for ins in line.inss :\n                ins.h.extend_sites(self.sites_type)\n</code></pre>"},{"location":"qmachine/#SimuQ.simuq.qmachine.SignalLine","title":"<code>SignalLine</code>","text":"<p>A signal line.</p> <p>It contains all instructions belonging to it.</p> Source code in <code>SimuQ/simuq/qmachine.py</code> <pre><code>class SignalLine :\n\"\"\" A signal line.\n\n    It contains all instructions belonging to it.\n    \"\"\"\n    def __init__(self, mach) :\n        self.mach = mach\n        self.index = mach.num_lines\n        mach.num_lines += 1\n        mach.lines.append(self)\n        self.inss = []\n</code></pre>"},{"location":"qsystem/","title":"Target Quantum Systems","text":"<p>The class for target Hamiltonian.</p> <p>It is a container of the desired piecewise constant evolution.</p>"},{"location":"qsystem/#SimuQ.simuq.qsystem.QSystem","title":"<code>QSystem</code>","text":"<p>         Bases: <code>BaseQuantumEnvironment</code></p> <p>A target quantum system.</p> <p>It contains a list of evolutions (h, t), which  represents evolving under h for time duration t.</p> <p>We also provide a syntax sugar to discretize a continuous-time Hamiltonian.</p> Source code in <code>SimuQ/simuq/qsystem.py</code> <pre><code>class QSystem(BaseQuantumEnvironment) :\n\"\"\" A target quantum system.\n\n    It contains a list of evolutions (h, t), which \n    represents evolving under h for time duration t.\n\n    We also provide a syntax sugar to discretize\n    a continuous-time Hamiltonian.\n    \"\"\"\n    def __init__(self) :\n        super().__init__()\n        self.evos = []\n\n    def add_evolution(self, h, t) :\n        self.evos.append((h, t))\n\n    def add_time_dependent_evolution(self, ht, ts) :\n        for i in range(len(ts) - 1) :\n            self.add_evolution(ht(ts[i]), ts[i + 1] - ts[i])\n\n    def clear_evos(self) :\n        self.evos = []\n</code></pre>"},{"location":"solver/","title":"SimuQ Solver","text":"<p>The solver of SimuQ.</p> <p>The solver contains three steps: (1) find an alignment of target sites and machine sites. (2) synthesize the target Hamiltonian with instructions without considering mutually exclusiveness. (3) trotterize the resulting boxes of instructions.</p> <p>The detailed descriptions are left in the implementations.</p>"}]}